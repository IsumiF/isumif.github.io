<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>My Hakyll Blog - fix and MonadFix in Haskell</title>
        <link rel="stylesheet" href="../../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../../">My Hakyll Blog</a>
            </div>
            <nav>
                <a href="../../">Home</a>
                <a href="../../about.html">About</a>
                <a href="../../contact.html">Contact</a>
                <a href="../../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>fix and MonadFix in Haskell</h1>
            <article>
    <section class="header">
        Posted on September 22, 2017
        
    </section>
    <section>
        <p>这里我们主要介绍<code>fix</code>,<code>MonadFix</code>与<code>mdo</code></p>
<h2 id="fix-函数"><code>fix</code> 函数</h2>
<p><code>fix</code>函数的定义来自<code>Control.Monad.Fix</code>，这是它的定义：</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fix ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a
fix f <span class="fu">=</span> <span class="kw">let</span> { x <span class="fu">=</span> f x } <span class="kw">in</span> x</code></pre></div>
<p>直观地来看，这个定义表示无限多个<code>f</code>依次应用下去</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f (f (f (f (<span class="fu">...</span>))))</code></pre></div>
<p>例如，<code>fix (1:) == [1,1..]</code></p>
<p>如果我们传递给<code>fix</code>的参数<code>f</code>对其参数严格求值，那么<code>fix f</code>一定是无法被计算 的，因为我们永远也无法把一个具体的值提供给<code>f</code>。事实上<code>fix f</code>收敛当且仅当<code>f</code>不严格求值</p>
<p>另一方面，<code>fix f</code>实际上求的是<code>f</code>的一个“不动点”，即下面的等式成立</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f (fix f) <span class="fu">=</span> fix f</code></pre></div>
<p>利用这一点我们可以推导，对于任意函数<code>f</code>，如果它能够被递归定义，就能够利用<code>fix</code>取代递归。 即：</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> a <span class="ot">-&gt;</span> b
f a <span class="fu">=</span> <span class="kw">if</span> p a
        <span class="kw">then</span> b0
        <span class="kw">else</span> g f a
<span class="co">-- 可以被替代为</span>
f <span class="fu">=</span> fix (\f' a <span class="ot">-&gt;</span>
  <span class="kw">if</span> p a
    <span class="kw">then</span> b0
    <span class="kw">else</span> g f' a)</code></pre></div>
<p>我们来证明这两种定义是等价的。 先来看类型：</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">p ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">b0 ::</span> b
<span class="ot">g ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</code></pre></div>
<p>记</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">h <span class="fu">=</span> \f' a <span class="ot">-&gt;</span> <span class="kw">if</span> p a
               <span class="kw">then</span> b0
               <span class="kw">else</span> g f' a</code></pre></div>
<p>利用<code>h (fix h) = fix h</code>有</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">=</span> fix h
  <span class="fu">=</span> h (fix h)
  <span class="fu">=</span> h f
  <span class="fu">=</span> \a <span class="ot">-&gt;</span> <span class="kw">if</span> p a
            <span class="kw">then</span> b0
            <span class="kw">else</span> g f a
<span class="co">-- 即有</span>
f a <span class="fu">=</span> <span class="kw">if</span> p a
        <span class="kw">then</span> b0
        <span class="kw">else</span> g f a</code></pre></div>
<p>与前面的递归定义比较，发现完全一致，这就表明递归定义可以转换为<code>fix</code>定义。另一方面， 由于<code>fix</code>本身是由递归定义的，所以<code>fix</code>定义也可以转换为递归定义。这就证明了两种定义方法 是等价的。因此理论上说我们可以在语言中放弃递归，转而提供<code>fix</code>作为最基本的语言特性</p>
<h3 id="further-reading">Further Reading</h3>
<p><a href="https://en.wikibooks.org/wiki/Haskell/Denotational_semantics">Denotational Semantics</a></p>
<h2 id="monadfix">MonadFix</h2>
<p>TODO</p>
<h2 id="mdo"><code>mdo</code></h2>
<p>TODO</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
